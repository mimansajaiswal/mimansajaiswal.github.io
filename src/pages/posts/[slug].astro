---
import NotionBlocks from "@/components/NotionBlocks.astro";
import PostLayout from "@/layouts/BlogPost.astro";
import {
	extractTargetBlocks,
	resetCurrentHeadings,
	resetFirstImage,
	setCurrentHeadings,
	setTrackCurrentPageId,
	getInterlinkedContentInPage,
	loadCachedHtml,
	loadCachedHeadings,
	saveCachedHeadings,
} from "@/lib/blog-helpers";
import { getAllPosts, getPostContentByPostId, processFileBlocks } from "@/lib/notion/client";
import type { Post } from "@/lib/interfaces";
import { buildHeadings } from "@/utils";
import { LAST_BUILD_TIME, CITATIONS } from "@/constants";
import { adjustedFootnotesConfig } from "@/lib/notion/client";
import type { Block } from "@/lib/interfaces";
import FootnotesSection from "@/components/blog/FootnotesSection.astro";
import BibliographySection from "@/components/blog/BibliographySection.astro";
import CiteThisPage from "@/components/blog/CiteThisPage.astro";

export async function getStaticPaths() {
	const posts = await getAllPosts();
	const allPostsMap: Record<string, Post> = Object.fromEntries(posts.map((p) => [p.PageId, p])); // Map of PageId to Post

	return posts.map((post) => {
		const interlinkedContentInPage = getInterlinkedContentInPage(post.PageId);
		const linkedPageIdsSet = new Set<string>(); // Use a Set to collect unique PageIds

		// Collect linked PageIds, automatically deduplicating
		if (interlinkedContentInPage) {
			interlinkedContentInPage.forEach((ref) => {
				if (ref.link_to_pageid) {
					linkedPageIdsSet.add(ref.link_to_pageid);
				}
				if (ref.other_pages) {
					ref.other_pages.forEach((richText) => {
						if (richText.InternalHref?.PageId) {
							linkedPageIdsSet.add(richText.InternalHref.PageId);
						} else if (richText.Mention?.Page?.PageId) {
							linkedPageIdsSet.add(richText.Mention.Page.PageId);
						}
					});
				}
			});
		}

		const linkedPageIds = Array.from(linkedPageIdsSet); // Convert Set back to an array

		// Check if the post was updated before LAST_BUILD_TIME
		const postLastUpdatedBeforeLastBuild =
			LAST_BUILD_TIME && post?.LastUpdatedTimeStamp && post.LastUpdatedTimeStamp < LAST_BUILD_TIME;

		// Check if any linked post was updated after LAST_BUILD_TIME
		const linkedPostsUpdated =
			!LAST_BUILD_TIME ||
			(linkedPageIds.length > 0 &&
				linkedPageIds.some((pageId) => {
					const linkedPost = allPostsMap[pageId];
					return linkedPost && linkedPost.LastUpdatedTimeStamp > LAST_BUILD_TIME;
				}));

		const shouldUseCache = postLastUpdatedBeforeLastBuild && !linkedPostsUpdated;

		return {
			params: { slug: post.Slug },
			props: { post, shouldUseCache, postLastUpdatedBeforeLastBuild },
		};
	});
}

interface Props {
	post: Post;
	shouldUseCache: boolean;
	postLastUpdatedBeforeLastBuild: boolean;
}

const { post, shouldUseCache, postLastUpdatedBeforeLastBuild } = Astro.props; // Extract shouldUseCache from props

resetCurrentHeadings();
let postFound = true;
let headings = null;
let blocks = null;
let interlinkedContentInPage = null;

if (!post) {
	console.log("Post not found. slug: ${slug}");
	postFound = false;
}

// Load cached HTML only if shouldUseCache is true
let cachedHtml = "";
if (postFound) {
	cachedHtml = await loadCachedHtml(post.Slug, shouldUseCache);
}

// Load cached headings if available
let cachedHeadings = null;
if (postFound) {
	cachedHeadings = await loadCachedHeadings(post.Slug, postLastUpdatedBeforeLastBuild);
}

let footnotesInPage = null;
let citationsInPage = null;

if (postFound) {
	const result = await getPostContentByPostId(post);
	blocks = result.blocks;
	interlinkedContentInPage = result.interlinkedContentInPage;
	footnotesInPage = result.footnotesInPage;
	citationsInPage = result.citationsInPage;
	// Use cached headings if available, otherwise build and save them
	if (cachedHeadings) {
		headings = cachedHeadings;
	} else {
		headings = buildHeadings(blocks);
		await saveCachedHeadings(post.Slug, headings);
	}

	setCurrentHeadings(headings);

	// Process file blocks only if cache isn't used
	const fileAtacchedBlocks = extractTargetBlocks(
		["image", "video", "file", "audio"],
		blocks,
	).filter((block) => {
		if (!block) return false;
		const imageOrVideoOrAudioOrFile = block.NImage || block.File || block.Video || block.NAudio;
		return (
			imageOrVideoOrAudioOrFile &&
			imageOrVideoOrAudioOrFile.File &&
			imageOrVideoOrAudioOrFile.File.Url
		);
	});

	await processFileBlocks(fileAtacchedBlocks);
}
---

{
	postFound && resetFirstImage() && setTrackCurrentPageId(post.PageId) && (
		<PostLayout
			post={post}
			headings={headings}
			shouldUseCache={shouldUseCache}
			footnotesInPage={footnotesInPage}
		>
			<div
				class="post-body max-w-[708px] print:max-w-full"
				data-html-type={shouldUseCache && cachedHtml ? "cached" : "new"}
			>
				{shouldUseCache && cachedHtml ? (
					<div set:html={cachedHtml} />
				) : (
					<>
						<NotionBlocks blocks={blocks} />
						{/* Footnotes section - only render when NOT using cache (cached HTML already includes it) */}
						{adjustedFootnotesConfig?.["in-page-footnotes-settings"]?.enabled &&
							adjustedFootnotesConfig?.["in-page-footnotes-settings"]?.[
								"generate-footnotes-section"
							] &&
							footnotesInPage && <FootnotesSection footnotes={footnotesInPage} />}
						{/* Bibliography section */}
						{CITATIONS?.["extract-and-process-bibtex-citations"]?.[
							"generate-bibliography-section"
						] &&
							citationsInPage &&
							citationsInPage.length > 0 && <BibliographySection citations={citationsInPage} />}
						{/* Cite This Page section */}
						{CITATIONS?.["add-cite-this-post-section"] && <CiteThisPage post={post} />}
					</>
				)}
			</div>
		</PostLayout>
	)
}
